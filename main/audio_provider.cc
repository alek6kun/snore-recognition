/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

#include "audio_provider.h"

#include <cstdlib>
#include <cstring>

// FreeRTOS.h must be included before some of the following dependencies.
// Solves b/150260343.
// clang-format off
#include "freertos/FreeRTOS.h"
// clang-format on
#include "driver/i2s_std.h"
#include "driver/gpio.h"
#include "esp_log.h"
#include "esp_spi_flash.h"
#include "esp_system.h"
#include "esp_timer.h"
#include "freertos/task.h"
#include "freertos/ringbuf.h"
#include "micro_model_settings.h"

using namespace std;

#define NO_I2S_SUPPORT CONFIG_IDF_TARGET_ESP32C2 || \
                          (CONFIG_IDF_TARGET_ESP32C3 \
                          && (ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(4, 4, 0)))

static const char* TAG = "TF_LITE_AUDIO_PROVIDER";

volatile int32_t g_latest_audio_timestamp = 0;

namespace {
  bool g_is_audio_initialized = false;
}  // namespace


#if NO_I2S_SUPPORT
  // nothing to be done here
#else
i2s_chan_handle_t rx_handle;

void i2s_init() {
  i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
  /* Allocate a new RX channel and get the handle of this channel */
  i2s_new_channel(&chan_cfg, NULL, &rx_handle);

  /* Setting the configurations, the slot configuration and clock configuration can be generated by the macros
  * These two helper macros are defined in 'i2s_std.h' which can only be used in STD mode.
  * They can help to specify the slot and clock configurations for initialization or updating */
  i2s_std_config_t std_cfg = {
      .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(kAudioSampleFrequency),
      .slot_cfg = I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_MONO),
      .gpio_cfg = {
          .mclk = I2S_GPIO_UNUSED,
          .bclk = GPIO_NUM_32,
          .ws = GPIO_NUM_25,
          .dout = I2S_GPIO_UNUSED,
          .din = GPIO_NUM_33,
          .invert_flags = {
              .mclk_inv = false,
              .bclk_inv = false,
              .ws_inv = false,
          },
      },
  };
  /* Initialize the channel */
  i2s_channel_init_std_mode(rx_handle, &std_cfg);

  /* Before reading data, start the RX channel first */
  i2s_channel_enable(rx_handle);
}
#endif

void capture_sample(int16_t* audio_samples, int nb_samples) {
  if (!g_is_audio_initialized) {
    i2s_init();
    g_is_audio_initialized = true;
  }

  size_t bytes_read = 0;
  esp_err_t result = i2s_channel_read(rx_handle, (int8_t*)audio_samples, 
                      nb_samples*2, &bytes_read, portMAX_DELAY);                
  if (bytes_read <= 0) {
    ESP_LOGE(TAG, "Error in I2S read : %d", bytes_read);
  } else { 
    if (bytes_read < nb_samples*2) {
      ESP_LOGW(TAG, "Partial I2S read");
    }
    if (result == ESP_OK) {
      /* sample swapping every two bytes because of how esp32 logs i2s*/     
      for (int i = 0; i < nb_samples; i+=2) {
        int16_t temp = audio_samples[i];
        audio_samples[i] = audio_samples[i+1];
        audio_samples[i+1] = temp;
      }
      /* update the timestamp (in ms) to let the model know that new data has
      * arrived */
      g_latest_audio_timestamp = g_latest_audio_timestamp +
          ((1000 * (bytes_read / 2)) / kAudioSampleFrequency);
    } else {
      ESP_LOGE(TAG, "Error in I2S read");
    }
  }
}
int32_t LatestAudioTimestamp() { return g_latest_audio_timestamp; }
